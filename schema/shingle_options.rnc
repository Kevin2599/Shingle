include "spud_base.rnc"

include "mesh_options.rnc"

start =
   (
      ## The root node of the options dictionary.
      element shingle_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element initialisation_name {
            anystring
         },
         ## Option problem_type does not change the tree.  It is just used for options checking.
         element problem_type {
            element string_value {
               # Lines is a hint to the gui about the size of the text box.
               # It is not an enforced limit on string length.
               attribute lines { "1" },
               ( "oceans" | "ocean_ice_shelf" | "geophysical" | "surface_geoid" | "stokes" )
            },
            comment
         },
         general,
         metric_options,
         mesh_options,
         geometry,
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            }
         },
         test
      }
   )      

general =
  (

    ## planet_radius = 6.37101e+06
    element source {
      attribute name { "source" },
      comment
    },

    ## dx_default = 0.1
    element source2 {
      attribute name { "source" },
      comment
    },


    # # Interestingly, if the following is true, gmsh generates a nice mesh, but complains (rightly so) on multiple definitions of a physical line id.  If false, the mesh contains extra 1d elements, which need parsing out!
    ## physical_lines_separate = False
    element source2 {
      attribute name { "source" },
      comment
    }



  )

surface_geoid_representation =
  (

    ## general
    ##   #fileid = 'G'
    ## fileid = ''
    element source2 {
      attribute name { "source" },
      comment
    },


    ## compound = False
    element source2 {
      attribute name { "source" },
      comment
    },

    ## more_bsplines = False
    element source2 {
      attribute name { "source" },
      comment
    },



    ## io

    ## source  = os.path.expanduser('~/tmp/dataset/rtopo/RTopo105b_50S.nc')
    element source {
      attribute name { "source" },
      comment
    },

    ## output = './shorelines.geo'
    element output {
      attribute name { "Output" },
      comment
    },

    ## contourtype = 'iceshelfcavity'
    element source2 {
      attribute name { "source" },
      comment
    },

    ## projection = 'cartesian'
    element source2 {
      attribute name { "source" },
      comment
    },


    ## boundaries = []
    element source2 {
      attribute name { "source" },
      comment
    },

    ## boundariestoexclude = []
    element source2 {
      attribute name { "source" },
      comment
    },

    ## dx = universe.dx_default
    element source2 {
      attribute name { "source" },
      comment
    },

    ## region = 'True'
    element source2 {
      attribute name { "source" },
      comment
    },

    ## box = []
    element source2 {
      attribute name { "source" },
      comment
    },

    ## minarea = 0
    element source2 {
      attribute name { "source" },
      comment
    },

    ## extendtolatitude = None
    element source2 {
      attribute name { "source" },
      comment
    },

    ## open = True
    element source2 {
      attribute name { "source" },
      comment
    },

    ## bounding_lat = -50.0
    element source2 {
      attribute name { "source" },
      comment
    },

    ## include_iceshelf_ocean_cavities = True
    element source2 {
      attribute name { "source" },
      comment
    },

    ## closewithparallels = False
    element source2 {
      attribute name { "source" },
      comment
    },

    ## elementlength = '1.0E5'
    element source2 {
      attribute name { "source" },
      comment
    },



    #processing
    # have separate rasters section?  - sources?
    ## smooth_data = False
    element source2 {
      attribute name { "source" },
      comment
    },

    ## smooth_degree = 100
    element source2 {
      attribute name { "source" },
      comment
    }



  )



mesh_options = 
  (
    ## generatemesh = False
    element source2 {
      attribute name { "source" },
      comment
    }


  )

metric_options = 
  (

    ## generatemetric = False
    element source2 {
      attribute name { "source" },
      comment
    }


  )
     
     
metric =
  (
     element metric {
        ## Metric definition
        element name {
          attribute name { "Metric name" },
          element name {
            anystring
          }
        }
     }
  )

mesh =
  (
     element mesh {
        ## Mesh definition
        element name {
          attribute name { "Mesh name" },
          element name {
            anystring
          }
        }
     }
  )


















## NetCDF CF 1.4 (http://cf-pcmdi.llnl.gov/)

raster_input_format =
  (
      ## raster input file format.
      element format {
         attribute name { "Raster" },
         ## The field to read from the vtu file. If not supplied, the name of
         ## the initialised field is used.
         element field_name {
            anystring,
            comment
         }?,
         comment
      }
  )




test =
  (
     element test {
        ## Test structure
        element node_number {
          attribute name { "Node number" },
          element tolerance {
            integer
          }
        },
        element element_number {
          attribute name { "Element number" },
          element tolerance {
            integer
          }
        },
        element surface_geoid_area {
          # Check correct in spherical projection
          attribute name { "Surface Geoid Area" },
          element tolerance {
            real
          }
        }?,
        element edge_node_number {
          attribute name { "Edge node number" },
          element tolerance {
            integer
          }
        },
        element element_circumsphere {
          attribute name { "Element circumsphere range" },
          element tolerance {
            integer
          }
        }?
     }
  )

geometry = 
   (
      ## Options dealing with the specification of geometry
      element geometry {
         ## Dimension of the problem.
         ## <b>This can only be set once</b>
         element dimension {
            element integer_value {
               attribute rank {"0"},
               ("3"|"2"|"1")
            }
         },
         ## The position mesh
         element mesh {
            attribute name { "CoordinateMesh" },
            mesh_info
         },
         ## The velocity mesh
         element mesh {
            attribute name { "VelocityMesh" },
            mesh_info
         }?,
         ## The pressure mesh
         element mesh {
            attribute name { "PressureMesh" },
            mesh_info
         }?,
         element mesh {
            attribute name { xsd:string },
            mesh_info,
            element exclude_from_mesh_adaptivity{empty}?
         }*,
         ## Quadrature
         element quadrature {
            ## Quadrature degree
            ## 
            ## note: this specifies the degree of quadrature,
            ## not the number of gauss points
            element degree {
               integer
            },
            ## Surface quadrature degree
            ## 
            ## note: this specifies the degree of surface
            ## quadrature not the number of surface gauss points
            element surface_degree {
               integer
            }?,
            ## Sets the degree of quadrature on each quadrilateral
            ## face of the control volume. 
            ##
            ## Defaults to 1 if
            ## unselected which is the same as pre-new options
            ## behaviour.
            element controlvolume_surface_degree {
               integer
            }?,
            ## Select which family of quadrature rules to use.
            ## The default is family_cools.
            ## family_wandzura allows for degree up to 30
            ## on triangular meshes.
            ## family_grundmann_moeller allows for degree up to
            ## 29 on simplicial meshes in arbitrary dimension.
            element quadrature_family {
               element string_value {
                  ( "family_cools" | "family_grundmann_moeller" | "family_wandzura" ) 
               }
            }?
         },
         ## This causes the change of variables associated with each element in 
         ## the mesh to be stored rather than calculated every time it is used. 
         ## This should speed up computations at a cost of some memory. 
         ## 
         ## The cache is automatically regenerated after mesh movement or 
         ## adaptivity and is automatically disabled for non-linear positions fields.
         element disable_geometric_data_cache {
            empty
         }?,
         ## Options specifying that the problem is on the surface of the sphere.
         element spherical_earth {
            (
               element linear_mapping {
                  empty
               }|
               ## Enabling this option approximates the curvature of the Earth as an
               ## nth degree polynomial, where n is the polynomial degree of the coordinate mesh.
               element superparametric_mapping {
                  empty
               }
            )
         }?,
         ## Options specifying the top surface and bottom of the domain
         ## used in various ocean calculations.
         element ocean_boundaries {
            ## Specify the surface ids that make up the top of the domain,
            ## i.e. the free surface or rigid lid.
            element top_surface_ids {
               integer_vector
            },
            ## Specify the surface ids that make up the bottom.
            element bottom_surface_ids {
               integer_vector
            },
            ## Diagnostic field giving the distance to the top surface.
            element scalar_field {
               attribute rank { "0" },
               attribute name { "DistanceToTop" },
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }
            },
            ## Diagnostic field giving the distance to ocean bottom.
            element scalar_field {
               attribute rank { "0" },
               attribute name { "DistanceToBottom" },
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }
            }
         }?
      }
   )
